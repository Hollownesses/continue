# Continue 企业级扩展实现方案

## 一、项目概述

基于 Continue 插件开发企业级 VSCode 插件，服务于：

- **企业代码库**：支持多仓库索引、远程代码库同步、权限控制
- **规则库**：集中化规则管理、规则版本控制、规则分类与搜索
- **模板库**：代码模板、提示词模板的统一管理和智能推荐

---

## 二、现有架构分析

### 2.1 Continue 核心组件

Continue 已有的核心能力：

1. **索引系统** (`core/indexing/`)

   - `CodebaseIndexer`: 统一索引管理器
   - `LanceDbIndex`: 向量数据库索引（支持语义搜索）
   - `FullTextSearchCodebaseIndex`: 全文搜索索引
   - `CodeSnippetsCodebaseIndex`: 代码片段索引
   - `ChunkCodebaseIndex`: 代码块索引

2. **规则系统** (`core/config/markdown/`)

   - `loadMarkdownRules`: 从本地 Markdown 文件加载规则
   - `loadCodebaseRules`: 代码库中的规则文件
   - 规则匹配与应用机制

3. **上下文提供者** (`core/context/providers/`)

   - `MCPContextProvider`: MCP 协议支持（可用于远程资源）
   - `CustomContextProvider`: 自定义上下文提供者
   - 支持本地和远程数据源

4. **配置系统** (`core/config/`)
   - YAML 配置加载
   - 远程配置支持（`remoteConfigServerUrl`）
   - 配置文件合并机制

---

## 三、需要新增的组件和模块

### 3.1 企业代码库模块 (`core/enterprise/codebase/`)

#### 3.1.1 远程代码库管理器

**文件路径**: `core/enterprise/codebase/RemoteCodebaseManager.ts`

```typescript
export class RemoteCodebaseManager {
  // 功能：
  // 1. 连接企业 Git 仓库（GitLab/GitHub Enterprise/Bitbucket）
  // 2. 同步远程仓库代码
  // 3. 增量更新索引
  // 4. 多仓库管理
  // 5. 权限验证

  async connectRemoteRepository(config: RemoteRepoConfig): Promise<void>;
  async syncRepository(repoId: string): Promise<SyncResult>;
  async getRepositoryList(): Promise<RemoteRepository[]>;
  async createIndexForRemoteRepo(repoId: string): Promise<void>;
}
```

**配置文件扩展** (`packages/config-yaml/src/schemas/enterprise/codebase.ts`):

```yaml
enterprise:
  codebase:
    repositories:
      - id: backend-repo
        name: Backend Service
        type: gitlab # 或 github-enterprise, bitbucket
        url: https://gitlab.company.com/backend
        branch: main
        auth:
          type: token
          token: ${{ secrets.GITLAB_TOKEN }}
        indexing:
          enabled: true
          patterns: ["**/*.ts", "**/*.js"]
          ignore: ["node_modules/**", "dist/**"]
```

#### 3.1.2 多仓库索引协调器

**文件路径**: `core/enterprise/codebase/MultiRepositoryIndexCoordinator.ts`

```typescript
export class MultiRepositoryIndexCoordinator {
  // 功能：
  // 1. 统一管理多个仓库的索引
  // 2. 跨仓库语义搜索
  // 3. 索引优先级和权重管理

  async indexMultipleRepos(repos: RemoteRepository[]): Promise<void>;
  async searchAcrossRepos(query: string, repos?: string[]): Promise<Chunk[]>;
  async getRepoIndexStatus(repoId: string): Promise<IndexStatus>;
}
```

#### 3.1.3 权限控制中间件

**文件路径**: `core/enterprise/codebase/CodebasePermissionManager.ts`

```typescript
export class CodebasePermissionManager {
  // 功能：
  // 1. 基于角色的访问控制 (RBAC)
  // 2. 代码库级别的权限管理
  // 3. 索引数据访问控制

  async checkAccess(
    userId: string,
    repoId: string,
    action: string,
  ): Promise<boolean>;
  async filterIndexedContent(
    content: Chunk[],
    userPermissions: UserPermissions,
  ): Promise<Chunk[]>;
}
```

### 3.2 企业规则库模块 (`core/enterprise/rules/`)

#### 3.2.1 远程规则库服务

**文件路径**: `core/enterprise/rules/RemoteRuleService.ts`

```typescript
export class RemoteRuleService {
  // 功能：
  // 1. 从远程规则库同步规则
  // 2. 规则版本管理
  // 3. 规则冲突解决
  // 4. 规则分类和标签

  async syncRulesFromRemote(source: RuleSource): Promise<RuleWithSource[]>;
  async getRuleVersions(ruleId: string): Promise<RuleVersion[]>;
  async resolveRuleConflicts(
    localRules: Rule[],
    remoteRules: Rule[],
  ): Promise<Rule[]>;
  async searchRules(query: string, category?: string): Promise<Rule[]>;
}
```

**配置文件扩展** (`packages/config-yaml/src/schemas/enterprise/rules.ts`):

```yaml
enterprise:
  rules:
    sources:
      - name: Company Standards
        type: http # 或 git, mcp
        url: https://rules.company.com/api/rules
        auth:
          type: bearer
          token: ${{ secrets.RULES_API_TOKEN }}
        sync:
          enabled: true
          interval: 3600 # 秒
          conflictResolution: remote-wins # 或 local-wins, merge
      - name: Team Rules
        type: git
        url: https://gitlab.company.com/team-rules
        branch: main
        path: .continue/rules
    categories:
      - id: security
        name: Security Rules
        priority: high
      - id: performance
        name: Performance Rules
        priority: medium
```

#### 3.2.2 规则模板引擎

**文件路径**: `core/enterprise/rules/RuleTemplateEngine.ts`

```typescript
export class RuleTemplateEngine {
  // 功能：
  // 1. 规则模板变量替换
  // 2. 动态规则生成
  // 3. 规则继承和组合

  async renderRuleTemplate(
    template: RuleTemplate,
    context: RuleContext,
  ): Promise<Rule>;
  async combineRules(rules: Rule[]): Promise<Rule>;
}
```

#### 3.2.3 规则缓存和版本管理

**文件路径**: `core/enterprise/rules/RuleVersionManager.ts`

```typescript
export class RuleVersionManager {
  // 功能：
  // 1. 规则版本历史
  // 2. 规则回滚
  // 3. 规则变更追踪

  async getRuleHistory(ruleId: string): Promise<RuleVersion[]>;
  async rollbackRule(ruleId: string, version: string): Promise<void>;
  async trackRuleChanges(ruleId: string): Promise<ChangeEvent[]>;
}
```

### 3.3 企业模板库模块 (`core/enterprise/templates/`)

#### 3.3.1 模板库管理器

**文件路径**: `core/enterprise/templates/TemplateLibraryManager.ts`

```typescript
export class TemplateLibraryManager {
  // 功能：
  // 1. 模板存储和检索
  // 2. 模板分类管理
  // 3. 模板搜索和推荐
  // 4. 模板使用统计

  async getTemplate(templateId: string): Promise<Template>;
  async searchTemplates(query: string, category?: string): Promise<Template[]>;
  async recommendTemplates(context: TemplateContext): Promise<Template[]>;
  async trackTemplateUsage(
    templateId: string,
    usage: TemplateUsage,
  ): Promise<void>;
}
```

**模板数据结构**:

```typescript
interface Template {
  id: string;
  name: string;
  description: string;
  category: string;
  tags: string[];
  content: string; // 模板内容
  variables: TemplateVariable[]; // 可替换变量
  metadata: {
    author: string;
    createdAt: string;
    updatedAt: string;
    usageCount: number;
    rating: number;
  };
  type: "code" | "prompt" | "config";
}
```

#### 3.3.2 代码模板引擎

**文件路径**: `core/enterprise/templates/CodeTemplateEngine.ts`

```typescript
export class CodeTemplateEngine {
  // 功能：
  // 1. 代码模板渲染
  // 2. 变量替换
  // 3. 条件逻辑处理
  // 4. 模板组合

  async renderCodeTemplate(
    template: CodeTemplate,
    variables: Record<string, any>,
  ): Promise<string>;
  async applyTemplateToFile(
    templateId: string,
    targetFile: string,
    context: TemplateContext,
  ): Promise<void>;
}
```

#### 3.3.3 提示词模板系统

**文件路径**: `core/enterprise/templates/PromptTemplateService.ts`

```typescript
export class PromptTemplateService {
  // 功能：
  // 1. 提示词模板管理
  // 2. 模板与 Continue slash commands 集成
  // 3. 动态提示词生成

  async createSlashCommandFromTemplate(
    template: PromptTemplate,
  ): Promise<SlashCommand>;
  async renderPromptTemplate(
    templateId: string,
    context: TemplateContext,
  ): Promise<string>;
}
```

**配置文件扩展** (`packages/config-yaml/src/schemas/enterprise/templates.ts`):

```yaml
enterprise:
  templates:
    sources:
      - name: Company Templates
        type: http
        url: https://templates.company.com/api
        auth:
          type: bearer
          token: ${{ secrets.TEMPLATES_TOKEN }}
      - name: Team Templates
        type: git
        url: https://gitlab.company.com/templates
        path: templates/
    categories:
      - id: api
        name: API Templates
      - id: database
        name: Database Templates
      - id: frontend
        name: Frontend Templates
    autoRecommend: true # 根据上下文自动推荐模板
```

### 3.4 企业服务集成层 (`core/enterprise/integration/`)

#### 3.4.1 统一认证服务

**文件路径**: `core/enterprise/integration/AuthService.ts`

```typescript
export class EnterpriseAuthService {
  // 功能：
  // 1. SSO/OAuth 集成
  // 2. Token 管理
  // 3. 用户权限获取

  async authenticate(
    provider: AuthProvider,
    credentials: Credentials,
  ): Promise<AuthResult>;
  async refreshToken(token: string): Promise<string>;
  async getUserPermissions(userId: string): Promise<UserPermissions>;
}
```

#### 3.4.2 API 客户端

**文件路径**: `core/enterprise/integration/EnterpriseApiClient.ts`

```typescript
export class EnterpriseApiClient {
  // 功能：
  // 1. 统一的企业 API 调用
  // 2. 请求重试和错误处理
  // 3. 缓存管理

  async callApi(endpoint: string, options: ApiOptions): Promise<ApiResponse>;
  async batchRequest(requests: ApiRequest[]): Promise<ApiResponse[]>;
}
```

---

## 四、架构集成方案

### 4.1 扩展现有索引系统

**修改文件**: `core/indexing/CodebaseIndexer.ts`

```typescript
// 扩展 getIndexesToBuild 方法
protected async getIndexesToBuild(): Promise<CodebaseIndex[]> {
  const indexes = await super.getIndexesToBuild();

  // 添加企业远程仓库索引
  const enterpriseIndexes = await this.buildEnterpriseIndexes();

  return [...indexes, ...enterpriseIndexes];
}

private async buildEnterpriseIndexes(): Promise<CodebaseIndex[]> {
  // 从配置加载企业代码库配置
  const { config } = await this.configHandler.loadConfig();
  const enterpriseRepos = config.enterprise?.codebase?.repositories || [];

  return enterpriseRepos.map(repo =>
    new EnterpriseRemoteIndex(repo, this.ide)
  );
}
```

### 4.2 扩展规则加载系统

**修改文件**: `core/config/profile/doLoadConfig.ts`

```typescript
async function loadRules(
  ide: IDE,
): Promise<{ rules: RuleWithSource[]; errors: any[] }> {
  // 现有规则加载
  const { rules: localRules, errors: localErrors } = await loadLocalRules(ide);

  // 新增：加载企业远程规则
  const enterpriseRuleService = new RemoteRuleService();
  const { rules: enterpriseRules, errors: enterpriseErrors } =
    await enterpriseRuleService.loadEnterpriseRules(ide);

  return {
    rules: [...localRules, ...enterpriseRules],
    errors: [...localErrors, ...enterpriseErrors],
  };
}
```

### 4.3 创建新的上下文提供者

**新文件**: `core/context/providers/EnterpriseTemplateContextProvider.ts`

```typescript
export class EnterpriseTemplateContextProvider extends BaseContextProvider {
  static description: ContextProviderDescription = {
    title: "enterprise-template",
    displayTitle: "Enterprise Templates",
    description: "Access enterprise code and prompt templates",
    type: "submenu",
  };

  async loadSubmenuItems(
    args: LoadSubmenuItemsArgs,
  ): Promise<ContextSubmenuItem[]> {
    const templateManager = new TemplateLibraryManager();
    const templates = await templateManager.getAllTemplates();

    return templates.map((template) => ({
      id: template.id,
      title: template.name,
      description: template.description,
    }));
  }

  async getContextItems(
    query: string,
    extras: ContextProviderExtras,
  ): Promise<ContextItem[]> {
    const templateManager = new TemplateLibraryManager();
    const template = await templateManager.getTemplate(query);

    return [
      {
        name: template.name,
        description: template.description,
        content: template.content,
      },
    ];
  }
}
```

### 4.4 集成 MCP 协议支持

利用 Continue 现有的 MCP 支持，可以创建企业 MCP 服务器：

**新文件**: `core/enterprise/mcp/EnterpriseMCPServer.ts`

```typescript
// 通过 MCP 协议暴露企业资源
export class EnterpriseMCPServer {
  // 将企业代码库、规则库、模板库作为 MCP Resources/Tools 暴露
  async registerEnterpriseResources(mcpClient: Client): Promise<void> {
    // 注册代码库资源
    await mcpClient.registerResource({
      uri: "enterprise://codebase/{repoId}",
      name: "Enterprise Codebase",
      description: "Access enterprise code repositories",
    });

    // 注册规则库工具
    await mcpClient.registerTool({
      name: "get_enterprise_rule",
      description: "Retrieve enterprise coding rules",
      inputSchema: {
        type: "object",
        properties: {
          ruleId: { type: "string" },
          category: { type: "string" },
        },
      },
    });
  }
}
```

---

## 五、配置文件结构

### 5.1 完整的 YAML 配置示例

```yaml
name: Enterprise Continue Configuration
version: 0.0.1
schema: v1

# 现有配置
models:
  - uses: anthropic/claude-3.5-sonnet

# 新增企业配置
enterprise:
  # 认证配置
  auth:
    provider: sso # 或 oauth, token
    endpoint: https://auth.company.com
    clientId: ${{ secrets.AUTH_CLIENT_ID }}

  # 代码库配置
  codebase:
    repositories:
      - id: main-backend
        name: Main Backend
        type: gitlab
        url: https://gitlab.company.com/backend/main
        branch: develop
        auth:
          type: token
          token: ${{ secrets.GITLAB_TOKEN }}
        indexing:
          enabled: true
          patterns: ["**/*.ts", "**/*.py"]
          priority: high

  # 规则库配置
  rules:
    sources:
      - name: Company Standards
        type: http
        url: https://rules.company.com/api
        sync:
          enabled: true
          interval: 3600
        conflictResolution: remote-wins
    categories:
      - id: security
        name: Security
        priority: high
      - id: style
        name: Code Style
        priority: medium

  # 模板库配置
  templates:
    sources:
      - name: Company Templates
        type: http
        url: https://templates.company.com/api
    autoRecommend: true
    categories:
      - id: api
        name: API Development
      - id: testing
        name: Testing Templates
```

---

## 六、实施优先级建议

### 阶段一：基础架构（1-2 周）

1. ✅ 创建企业模块目录结构
2. ✅ 实现统一认证服务
3. ✅ 创建 API 客户端基础框架
4. ✅ 扩展配置系统支持企业配置

### 阶段二：代码库模块（2-3 周）

1. ✅ 实现远程代码库管理器
2. ✅ 多仓库索引协调器
3. ✅ 权限控制中间件
4. ✅ 集成到现有索引系统

### 阶段三：规则库模块（2-3 周）

1. ✅ 远程规则库服务
2. ✅ 规则版本管理
3. ✅ 规则冲突解决
4. ✅ 集成到规则加载系统

### 阶段四：模板库模块（2-3 周）

1. ✅ 模板库管理器
2. ✅ 代码模板引擎
3. ✅ 提示词模板系统
4. ✅ 创建上下文提供者

### 阶段五：集成与优化（1-2 周）

1. ✅ MCP 协议集成
2. ✅ UI 界面增强
3. ✅ 性能优化
4. ✅ 文档完善

---

## 七、关键技术点

### 7.1 数据同步策略

- **增量同步**：使用 Git diff 检测变更
- **缓存机制**：本地缓存减少网络请求
- **冲突解决**：支持多种策略（remote-wins, local-wins, merge）

### 7.2 索引优化

- **分布式索引**：多仓库索引并行处理
- **索引压缩**：使用压缩算法减少存储
- **增量更新**：只索引变更文件

### 7.3 权限控制

- **基于角色的访问控制 (RBAC)**
- **细粒度权限**：文件级别、目录级别
- **权限缓存**：减少权限检查开销

### 7.4 性能考虑

- **异步处理**：所有 I/O 操作异步化
- **批量操作**：合并多个 API 请求
- **智能缓存**：缓存频繁访问的数据

---

## 八、测试策略

### 8.1 单元测试

- 各模块核心功能测试
- Mock 远程服务

### 8.2 集成测试

- 端到端流程测试
- 多仓库索引测试
- 规则同步测试

### 8.3 性能测试

- 大规模代码库索引性能
- 并发请求处理能力

---

## 九、后续扩展方向

1. **AI 增强**

   - 基于使用模式的智能推荐
   - 规则自动生成
   - 代码质量自动评估

2. **协作功能**

   - 团队规则共享
   - 模板协作编辑
   - 使用统计和洞察

3. **企业集成**
   - Jira/Confluence 集成
   - Slack/Teams 通知
   - CI/CD 流水线集成

---

## 十、总结

本方案基于 Continue 的现有架构，通过扩展的方式实现了企业级功能：

1. **最小侵入**：充分利用 Continue 的插件机制和扩展点
2. **模块化设计**：各功能模块独立，易于维护和扩展
3. **标准化接口**：使用 MCP 协议和标准 API 设计
4. **可扩展性**：支持多种数据源和认证方式

通过以上实现，可以构建一个功能完整的企业级 VSCode AI 辅助开发插件。
